# Архитектурный астронавт

## Выбор технологий.

1. Очевидно, в проекте нужна какая-то библиотека для UI. 
   Эпоха jQuery и подобных давно прошла. Значит, React.

2. Очевидно, нужно рендерить шаблоны на клиенте, т.к. не хочется на 
   сервере перемешивать данные (типа JSON) и верстку (типа HTML+CSS)
   
3. Первое состояние наверное хорошо бы рендерить прямо на сервере, но это 
   довольно сложно если не используешь NodeJS на сервере. Пока что отложим SSR.
   Ну а на сервере Go.
   
4. Хочется чтобы был явный контракт между клиентом и сервером. Нужна какая-то
   формальная штука чтобы типизированно описывать ответы от сервера. 
   
5. Хочется чтобы формат ответа от сервера был JSON. Он максимально удобен 
   и нативен клиента/JavaScript.
   
6. Из вариантов сделать схемку остается JSON Schema (это убого) либо
   Protobuf, но от него нужна только схема и автоген Typescript-типов, 
   непосредсвтенно бинарная сериализация нам не нужна.
   
7. Для гошки заюзаем либу gogoproto, для TS - либку ts-proto.

## Роутинг

1. Правильно, чтобы клиент совершенн ничего не знал про роутинг. Весь роутинг должен
   быть на сервере.
   
2. Клиент не должен сам решать, какой компонент показать "в ответ" на изменение урла.

3. Как только нужно пронавигироваться, клиент должен обратиться на сервер чтобы 
   "зарезолвить" роут (см. `resolveRoute` в js). В ответе будет какой React-компонент 
   нужно отобразить и данные (пропсы) для этого компонента.
   
## Дизайн API

1. В принципе, для апи-методов которые "открываются" по роутеру, традиционные
   "апи-эндпоинты" не нужны, т.к. данные там приходят чере роутер.

2. Однако, традиционные апи-методы нужны для создания поста например (т.е. всякого 
   рода мутации данных).

3. Также обычные апи-методы нужны там, где нужна дозагрузка данных без навигации. 
   Это штуки наподобие открытия какого-то UI элемента "поверх" вроде всплывающих тултипов и т.д.

## Авторизация

1. Авторизация происходит через АПИ-токен. 

2. Для Javascript было бы хорошо прозрачно добавлять токен к запросам
   через куки. Так клиентский код вообще не парится о токене, и это
   более безопасно если взять HttpOnly-куки.
   
3. Когда есть авторизация через куки, нужно придумать защиту от CSRF.

## Хедер

1. На странице есть части (хедер) которые редко обновляются, на каждый
   запрос их пересылать выглядит невыгодно. Хорошо бы при старте запросить
   один раз, затем раз в какое-то время перезапрашивать свежие данные.