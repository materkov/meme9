# Архитектурный астронавт

## Выбор технологий.

1. Очевидно, в проекте нужна какая-то библиотека для UI. 
   Эпоха jQuery и подобных давно прошла. Значит, React.

2. Очевидно, нужно рендерить шаблоны на клиенте, т.к. не хочется на 
   сервере перемешивать данные (типа JSON) и верстку (типа HTML+CSS)
   
3. Первое состояние наверное хорошо бы рендерить прямо на сервере, но это 
   довольно сложно если не используешь NodeJS на сервере. Пока что отложим SSR.
   Ну а на сервере Go.
   
4. Хочется чтобы был явный контракт между клиентом и сервером. Нужна какая-то
   формальная штука чтобы типизированно описывать ответы от сервера. 
   
5. Хочется чтобы формат ответа от сервера был JSON. Он максимально удобен 
   и нативен клиента/JavaScript.
   
6. Из вариантов сделать схемку остается JSON Schema (это убого) либо
   Protobuf, но от него нужна только схема и автоген Typescript-типов, 
   непосредсвтенно бинарная сериализация нам не нужна.
   
7. Для гошки заюзаем либу gogoproto, для TS - либку ts-proto.

## Роутинг

1. Правильно, чтобы клиент совершенн ничего не знал про роутинг. Весь роутинг должен
   быть на сервере.
   
2. Клиент не должен сам решать, какой компонент показать "в ответ" на изменение урла.

3. Как только нужно пронавигироваться, клиент должен обратиться на сервер чтобы 
   "зарезолвить" роут (см. `resolveRoute` в js). В ответе будет какой React-компонент 
   нужно отобразить и данные (пропсы) для этого компонента.
   
## Дизайн API

1. В принципе, для апи-методов которые "открываются" по роутеру, традиционные
   "апи-эндпоинты" не нужны, т.к. данные там приходят чере роутер.

2. Однако, традиционные апи-методы нужны для создания поста например (т.е. всякого 
   рода мутации данных).

3. Также обычные апи-методы нужны там, где нужна дозагрузка данных без навигации. 
   Это штуки наподобие открытия какого-то UI элемента "поверх" вроде всплывающих тултипов и т.д.

## Авторизация

1. Авторизация происходит через АПИ-токен. 

2. Для Javascript было бы хорошо прозрачно добавлять токен к запросам
   через куки. Так клиентский код вообще не парится о токене, и это
   более безопасно если взять HttpOnly-куки.
   
3. Когда есть авторизация через куки, нужно придумать защиту от CSRF.

## Хедер

1. На странице есть части (хедер) которые редко обновляются, на каждый
   запрос их пересылать выглядит невыгодно. Хорошо бы при старте запросить
   один раз, затем раз в какое-то время перезапрашивать свежие данные.
   
## База данных

1. Реляционные базы не хочется юзать, т.к. запаришься писать маппер между
   объектами и колонками, сложности если нужно сделать массив или сложный объект.
   
2. Можно хранить объекты в виде json или msgpack. 

3. Удобно чтобы у каждого объекта был уникальный int64 id. Удобно было бы зная id 
   узнавать тип объекта.

4. Удобно, чтоб в гошке был какой-то легкий способ замокать БД,
   без необходимости писать репозиторий под каждую сущность. Это слишком долго,
   не хочется парится.

5. Кажется, было бы просто объявить модель в коде, и сериализовать ее 
   в JSON для (1) отдачи на клиент и (2) сохранения в БД. Первое все-таки
   не очень хорошая идея, т.к. объект нужно "дообогощать" разными доп. данными,
   связанными объектами и т.д. А вот сохранять в БД модель напрямую кажется
   самое оно.
   
6. Хорошего решения пока нет, используем либу sqlx. Непонятно, что делать со сложными моделями
   (со вложенными данными, массивами и т.д.)

## Добавлям, развиваем дальше

1. Странно получилось, что есть 2 самописных роутера (на методы апи и на обычный роутинг).
   Писать самому и обрабатывать регулярки как-то не очень вышло.
   
2. Объединим все в одно, уберем префикс /router. Возьмем готовую либу gorila-mux для гошки.

3. Каждый раз добавляя новую страницу, нужно писать обетку в котором будет единственное поле
   renderer. Это получилось утомительно. К тому же, нужно не забыть что надо добавить новое значение в ENUM.
   
4. Можно добавить класс UniversalRenderer, в котором будет oneof всех корневых рендереров.
